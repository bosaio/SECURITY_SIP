"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/react/node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n\nconst defaultLists = {\n  number: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", { children }),\n  bullet: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { children })\n}, DefaultListItem = ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { children }), link = ({ children, value }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", { href: value == null ? void 0 : value.href, children }), underlineStyle = { textDecoration: \"underline\" }, defaultMarks = {\n  em: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", { children }),\n  strong: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", { children }),\n  code: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", { children }),\n  underline: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: underlineStyle, children }),\n  \"strike-through\": ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", { children }),\n  link\n}, getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`, unknownTypeWarning = (typeName) => getTemplate(`block type \"${typeName}\"`, \"types\"), unknownMarkWarning = (markType) => getTemplate(`mark type \"${markType}\"`, \"marks\"), unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style \"${blockStyle}\"`, \"block\"), unknownListStyleWarning = (listStyle) => getTemplate(`list style \"${listStyle}\"`, \"list\"), unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = { display: \"none\" }, DefaultUnknownType = ({\n  value,\n  isInline\n}) => {\n  const warning = unknownTypeWarning(value._type);\n  return isInline ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: hidden, children: warning }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: hidden, children: warning });\n}, DefaultUnknownMark = ({\n  markType,\n  children\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { className: `unknown__pt__mark__${markType}`, children }), DefaultUnknownBlockStyle = ({\n  children\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { children }), DefaultUnknownList = ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", { children }), DefaultUnknownListItem = ({\n  children\n}) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", { children }), DefaultHardBreak = () => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}), defaultBlockStyles = {\n  normal: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", { children }),\n  blockquote: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", { children }),\n  h1: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", { children }),\n  h2: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", { children }),\n  h3: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", { children }),\n  h4: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", { children }),\n  h5: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", { children }),\n  h6: ({ children }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", { children })\n}, defaultComponents = {\n  types: {},\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle\n};\nfunction mergeComponents(parent, overrides) {\n  const { block, list, listItem, marks, types, ...rest } = overrides;\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\"),\n    ...rest\n  };\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key], parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? { ...parentVal, ...override } : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [input], nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML), components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]), renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent]\n  ), rendered = nested.map(\n    (node, index) => renderNode({ node, index, isInline: !1, renderNode })\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: rendered });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const { node, index, isInline } = options, key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({ node, index, isInline: !1, renderNode }), renderer = components.listItem, Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const { listItem, ...blockNode } = node;\n      children = renderNode({ node: blockNode, index, isInline: !1 });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, { value: node, index, isInline: !1, renderNode, children }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map(\n      (child, childIndex) => renderNode({\n        node: child._key ? child : { ...child, _key: `li-${index}-${childIndex}` },\n        index: childIndex,\n        isInline: !1\n      })\n    ), component = components.list, List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), { nodeType: \"listStyle\", type: style });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, { value: node, index, isInline: !1, renderNode, children }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map(\n      (child, childIndex) => renderNode({ node: child, index: childIndex, isInline: !0 })\n    );\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), { nodeType: \"mark\", type: markType }), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      Span,\n      {\n        text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n        value: markDef,\n        markType,\n        markKey,\n        renderNode,\n        children\n      },\n      key\n    );\n  }\n  function renderBlock(node, index, key, isInline) {\n    const { _key, ...props } = serializeBlock({ node, index, isInline, renderNode }), style = props.node.style || \"normal\", Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, { ...props, value: props.node, renderNode }, key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), { nodeType: \"block\", type: node._type });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, { ...nodeOptions }, key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    }, Node = components.types[node._type];\n    return Node ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, { ...nodeOptions }, key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const { node, index, isInline, renderNode } = options, children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map(\n    (child, i) => renderNode({ node: child, isInline: !0, index: i, renderNode })\n  );\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBa0Q7QUFDNkw7QUFDM0w7QUFDcEI7QUFDaEM7QUFDQSxhQUFhLFVBQVUscUJBQXFCLHNEQUFHLFNBQVMsVUFBVTtBQUNsRSxhQUFhLFVBQVUscUJBQXFCLHNEQUFHLFNBQVMsVUFBVTtBQUNsRSxDQUFDLHVCQUF1QixVQUFVLHFCQUFxQixzREFBRyxTQUFTLFVBQVUsYUFBYSxpQkFBaUIscUJBQXFCLHNEQUFHLFFBQVEscURBQXFELHNCQUFzQiw2QkFBNkI7QUFDblAsU0FBUyxVQUFVLHFCQUFxQixzREFBRyxTQUFTLFVBQVU7QUFDOUQsYUFBYSxVQUFVLHFCQUFxQixzREFBRyxhQUFhLFVBQVU7QUFDdEUsV0FBVyxVQUFVLHFCQUFxQixzREFBRyxXQUFXLFVBQVU7QUFDbEUsZ0JBQWdCLFVBQVUscUJBQXFCLHNEQUFHLFdBQVcsaUNBQWlDO0FBQzlGLHVCQUF1QixVQUFVLHFCQUFxQixzREFBRyxVQUFVLFVBQVU7QUFDN0U7QUFDQSxDQUFDLGlFQUFpRSxLQUFLLG1EQUFtRCxLQUFLLHdFQUF3RSxTQUFTLDJFQUEyRSxTQUFTLHFGQUFxRixXQUFXLGtGQUFrRixVQUFVLDBGQUEwRixVQUFVO0FBQ3BrQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQ0FBb0Msc0RBQUcsV0FBVyxrQ0FBa0Msb0JBQW9CLHNEQUFHLFVBQVUsa0NBQWtDO0FBQ3ZKLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIsc0RBQUcsV0FBVyxpQ0FBaUMsU0FBUyxhQUFhO0FBQzNGO0FBQ0EsQ0FBQyxxQkFBcUIsc0RBQUcsUUFBUSxVQUFVLDJCQUEyQixVQUFVLHFCQUFxQixzREFBRyxTQUFTLFVBQVU7QUFDM0g7QUFDQSxDQUFDLHFCQUFxQixzREFBRyxTQUFTLFVBQVUs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dHktc2lwLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3JlYWN0L2Rpc3QvaW5kZXguanM/MTc4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBuZXN0TGlzdHMsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIHNwYW5Ub1BsYWluVGV4dCwgYnVpbGRNYXJrc1RyZWUgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB0b1BsYWluVGV4dCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGRlZmF1bHRMaXN0cyA9IHtcbiAgbnVtYmVyOiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwib2xcIiwgeyBjaGlsZHJlbiB9KSxcbiAgYnVsbGV0OiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwidWxcIiwgeyBjaGlsZHJlbiB9KVxufSwgRGVmYXVsdExpc3RJdGVtID0gKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImxpXCIsIHsgY2hpbGRyZW4gfSksIGxpbmsgPSAoeyBjaGlsZHJlbiwgdmFsdWUgfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImFcIiwgeyBocmVmOiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuaHJlZiwgY2hpbGRyZW4gfSksIHVuZGVybGluZVN0eWxlID0geyB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LCBkZWZhdWx0TWFya3MgPSB7XG4gIGVtOiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiZW1cIiwgeyBjaGlsZHJlbiB9KSxcbiAgc3Ryb25nOiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwic3Ryb25nXCIsIHsgY2hpbGRyZW4gfSksXG4gIGNvZGU6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJjb2RlXCIsIHsgY2hpbGRyZW4gfSksXG4gIHVuZGVybGluZTogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBzdHlsZTogdW5kZXJsaW5lU3R5bGUsIGNoaWxkcmVuIH0pLFxuICBcInN0cmlrZS10aHJvdWdoXCI6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkZWxcIiwgeyBjaGlsZHJlbiB9KSxcbiAgbGlua1xufSwgZ2V0VGVtcGxhdGUgPSAodHlwZSwgcHJvcCkgPT4gYFtAcG9ydGFibGV0ZXh0L3JlYWN0XSBVbmtub3duICR7dHlwZX0sIHNwZWNpZnkgYSBjb21wb25lbnQgZm9yIGl0IGluIHRoZSBcXGBjb21wb25lbnRzLiR7cHJvcH1cXGAgcHJvcGAsIHVua25vd25UeXBlV2FybmluZyA9ICh0eXBlTmFtZSkgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHR5cGUgXCIke3R5cGVOYW1lfVwiYCwgXCJ0eXBlc1wiKSwgdW5rbm93bk1hcmtXYXJuaW5nID0gKG1hcmtUeXBlKSA9PiBnZXRUZW1wbGF0ZShgbWFyayB0eXBlIFwiJHttYXJrVHlwZX1cImAsIFwibWFya3NcIiksIHVua25vd25CbG9ja1N0eWxlV2FybmluZyA9IChibG9ja1N0eWxlKSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgc3R5bGUgXCIke2Jsb2NrU3R5bGV9XCJgLCBcImJsb2NrXCIpLCB1bmtub3duTGlzdFN0eWxlV2FybmluZyA9IChsaXN0U3R5bGUpID0+IGdldFRlbXBsYXRlKGBsaXN0IHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RcIiksIHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IChsaXN0U3R5bGUpID0+IGdldFRlbXBsYXRlKGBsaXN0IGl0ZW0gc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdEl0ZW1cIik7XG5mdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5jb25zdCBoaWRkZW4gPSB7IGRpc3BsYXk6IFwibm9uZVwiIH0sIERlZmF1bHRVbmtub3duVHlwZSA9ICh7XG4gIHZhbHVlLFxuICBpc0lubGluZVxufSkgPT4ge1xuICBjb25zdCB3YXJuaW5nID0gdW5rbm93blR5cGVXYXJuaW5nKHZhbHVlLl90eXBlKTtcbiAgcmV0dXJuIGlzSW5saW5lID8gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBzdHlsZTogaGlkZGVuLCBjaGlsZHJlbjogd2FybmluZyB9KSA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBzdHlsZTogaGlkZGVuLCBjaGlsZHJlbjogd2FybmluZyB9KTtcbn0sIERlZmF1bHRVbmtub3duTWFyayA9ICh7XG4gIG1hcmtUeXBlLFxuICBjaGlsZHJlblxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGB1bmtub3duX19wdF9fbWFya19fJHttYXJrVHlwZX1gLCBjaGlsZHJlbiB9KSwgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwXCIsIHsgY2hpbGRyZW4gfSksIERlZmF1bHRVbmtub3duTGlzdCA9ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJ1bFwiLCB7IGNoaWxkcmVuIH0pLCBEZWZhdWx0VW5rbm93bkxpc3RJdGVtID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJsaVwiLCB7IGNoaWxkcmVuIH0pLCBEZWZhdWx0SGFyZEJyZWFrID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImJyXCIsIHt9KSwgZGVmYXVsdEJsb2NrU3R5bGVzID0ge1xuICBub3JtYWw6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwXCIsIHsgY2hpbGRyZW4gfSksXG4gIGJsb2NrcXVvdGU6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJibG9ja3F1b3RlXCIsIHsgY2hpbGRyZW4gfSksXG4gIGgxOiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiaDFcIiwgeyBjaGlsZHJlbiB9KSxcbiAgaDI6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJoMlwiLCB7IGNoaWxkcmVuIH0pLFxuICBoMzogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImgzXCIsIHsgY2hpbGRyZW4gfSksXG4gIGg0OiAoeyBjaGlsZHJlbiB9KSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFwiaDRcIiwgeyBjaGlsZHJlbiB9KSxcbiAgaDU6ICh7IGNoaWxkcmVuIH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJoNVwiLCB7IGNoaWxkcmVuIH0pLFxuICBoNjogKHsgY2hpbGRyZW4gfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImg2XCIsIHsgY2hpbGRyZW4gfSlcbn0sIGRlZmF1bHRDb21wb25lbnRzID0ge1xuICB0eXBlczoge30sXG4gIGJsb2NrOiBkZWZhdWx0QmxvY2tTdHlsZXMsXG4gIG1hcmtzOiBkZWZhdWx0TWFya3MsXG4gIGxpc3Q6IGRlZmF1bHRMaXN0cyxcbiAgbGlzdEl0ZW06IERlZmF1bHRMaXN0SXRlbSxcbiAgaGFyZEJyZWFrOiBEZWZhdWx0SGFyZEJyZWFrLFxuICB1bmtub3duVHlwZTogRGVmYXVsdFVua25vd25UeXBlLFxuICB1bmtub3duTWFyazogRGVmYXVsdFVua25vd25NYXJrLFxuICB1bmtub3duTGlzdDogRGVmYXVsdFVua25vd25MaXN0LFxuICB1bmtub3duTGlzdEl0ZW06IERlZmF1bHRVbmtub3duTGlzdEl0ZW0sXG4gIHVua25vd25CbG9ja1N0eWxlOiBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGVcbn07XG5mdW5jdGlvbiBtZXJnZUNvbXBvbmVudHMocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgY29uc3QgeyBibG9jaywgbGlzdCwgbGlzdEl0ZW0sIG1hcmtzLCB0eXBlcywgLi4ucmVzdCB9ID0gb3ZlcnJpZGVzO1xuICByZXR1cm4ge1xuICAgIC4uLnBhcmVudCxcbiAgICBibG9jazogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwiYmxvY2tcIiksXG4gICAgbGlzdDogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdFwiKSxcbiAgICBsaXN0SXRlbTogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdEl0ZW1cIiksXG4gICAgbWFya3M6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcIm1hcmtzXCIpLFxuICAgIHR5cGVzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJ0eXBlc1wiKSxcbiAgICAuLi5yZXN0XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gb3ZlcnJpZGVzW2tleV0sIHBhcmVudFZhbCA9IHBhcmVudFtrZXldO1xuICByZXR1cm4gdHlwZW9mIG92ZXJyaWRlID09IFwiZnVuY3Rpb25cIiB8fCBvdmVycmlkZSAmJiB0eXBlb2YgcGFyZW50VmFsID09IFwiZnVuY3Rpb25cIiA/IG92ZXJyaWRlIDogb3ZlcnJpZGUgPyB7IC4uLnBhcmVudFZhbCwgLi4ub3ZlcnJpZGUgfSA6IHBhcmVudFZhbDtcbn1cbmZ1bmN0aW9uIFBvcnRhYmxlVGV4dCh7XG4gIHZhbHVlOiBpbnB1dCxcbiAgY29tcG9uZW50czogY29tcG9uZW50T3ZlcnJpZGVzLFxuICBsaXN0TmVzdGluZ01vZGUsXG4gIG9uTWlzc2luZ0NvbXBvbmVudDogbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgPSBwcmludFdhcm5pbmdcbn0pIHtcbiAgY29uc3QgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3AsIGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdLCBuZXN0ZWQgPSBuZXN0TGlzdHMoYmxvY2tzLCBsaXN0TmVzdGluZ01vZGUgfHwgTElTVF9ORVNUX01PREVfSFRNTCksIGNvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IGNvbXBvbmVudE92ZXJyaWRlcyA/IG1lcmdlQ29tcG9uZW50cyhkZWZhdWx0Q29tcG9uZW50cywgY29tcG9uZW50T3ZlcnJpZGVzKSA6IGRlZmF1bHRDb21wb25lbnRzLCBbY29tcG9uZW50T3ZlcnJpZGVzXSksIHJlbmRlck5vZGUgPSB1c2VNZW1vKFxuICAgICgpID0+IGdldE5vZGVSZW5kZXJlcihjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSxcbiAgICBbY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudF1cbiAgKSwgcmVuZGVyZWQgPSBuZXN0ZWQubWFwKFxuICAgIChub2RlLCBpbmRleCkgPT4gcmVuZGVyTm9kZSh7IG5vZGUsIGluZGV4LCBpc0lubGluZTogITEsIHJlbmRlck5vZGUgfSlcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHJlbmRlcmVkIH0pO1xufVxuY29uc3QgZ2V0Tm9kZVJlbmRlcmVyID0gKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpID0+IHtcbiAgZnVuY3Rpb24gcmVuZGVyTm9kZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBub2RlLCBpbmRleCwgaXNJbmxpbmUgfSA9IG9wdGlvbnMsIGtleSA9IG5vZGUuX2tleSB8fCBgbm9kZS0ke2luZGV4fWA7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qobm9kZSkgPyByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIDogaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKG5vZGUpID8gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuKG5vZGUpID8gcmVuZGVyU3Bhbihub2RlLCBpbmRleCwga2V5KSA6IGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkgPyByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpID8gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkgPyByZW5kZXJUZXh0KG5vZGUsIGtleSkgOiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuX3R5cGUgaW4gY29tcG9uZW50cy50eXBlcztcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgdHJlZSA9IHNlcmlhbGl6ZUJsb2NrKHsgbm9kZSwgaW5kZXgsIGlzSW5saW5lOiAhMSwgcmVuZGVyTm9kZSB9KSwgcmVuZGVyZXIgPSBjb21wb25lbnRzLmxpc3RJdGVtLCBMaSA9ICh0eXBlb2YgcmVuZGVyZXIgPT0gXCJmdW5jdGlvblwiID8gcmVuZGVyZXIgOiByZW5kZXJlcltub2RlLmxpc3RJdGVtXSkgfHwgY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW07XG4gICAgaWYgKExpID09PSBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmxpc3RJdGVtIHx8IFwiYnVsbGV0XCI7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgdHlwZTogc3R5bGUsXG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RJdGVtU3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gICAgaWYgKG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgY29uc3QgeyBsaXN0SXRlbSwgLi4uYmxvY2tOb2RlIH0gPSBub2RlO1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJOb2RlKHsgbm9kZTogYmxvY2tOb2RlLCBpbmRleCwgaXNJbmxpbmU6ICExIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChMaSwgeyB2YWx1ZTogbm9kZSwgaW5kZXgsIGlzSW5saW5lOiAhMSwgcmVuZGVyTm9kZSwgY2hpbGRyZW4gfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJMaXN0KG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKFxuICAgICAgKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQuX2tleSA/IGNoaWxkIDogeyAuLi5jaGlsZCwgX2tleTogYGxpLSR7aW5kZXh9LSR7Y2hpbGRJbmRleH1gIH0sXG4gICAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBpc0lubGluZTogITFcbiAgICAgIH0pXG4gICAgKSwgY29tcG9uZW50ID0gY29tcG9uZW50cy5saXN0LCBMaXN0ID0gKHR5cGVvZiBjb21wb25lbnQgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50IDogY29tcG9uZW50W25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0O1xuICAgIGlmIChMaXN0ID09PSBjb21wb25lbnRzLnVua25vd25MaXN0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RTdHlsZVdhcm5pbmcoc3R5bGUpLCB7IG5vZGVUeXBlOiBcImxpc3RTdHlsZVwiLCB0eXBlOiBzdHlsZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goTGlzdCwgeyB2YWx1ZTogbm9kZSwgaW5kZXgsIGlzSW5saW5lOiAhMSwgcmVuZGVyTm9kZSwgY2hpbGRyZW4gfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJTcGFuKG5vZGUsIF9pbmRleCwga2V5KSB7XG4gICAgY29uc3QgeyBtYXJrRGVmLCBtYXJrVHlwZSwgbWFya0tleSB9ID0gbm9kZSwgU3BhbiA9IGNvbXBvbmVudHMubWFya3NbbWFya1R5cGVdIHx8IGNvbXBvbmVudHMudW5rbm93bk1hcmssIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoXG4gICAgICAoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoeyBub2RlOiBjaGlsZCwgaW5kZXg6IGNoaWxkSW5kZXgsIGlzSW5saW5lOiAhMCB9KVxuICAgICk7XG4gICAgcmV0dXJuIFNwYW4gPT09IGNvbXBvbmVudHMudW5rbm93bk1hcmsgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTWFya1dhcm5pbmcobWFya1R5cGUpLCB7IG5vZGVUeXBlOiBcIm1hcmtcIiwgdHlwZTogbWFya1R5cGUgfSksIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBTcGFuLFxuICAgICAge1xuICAgICAgICB0ZXh0OiBzcGFuVG9QbGFpblRleHQobm9kZSksXG4gICAgICAgIHZhbHVlOiBtYXJrRGVmLFxuICAgICAgICBtYXJrVHlwZSxcbiAgICAgICAgbWFya0tleSxcbiAgICAgICAgcmVuZGVyTm9kZSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0sXG4gICAgICBrZXlcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3QgeyBfa2V5LCAuLi5wcm9wcyB9ID0gc2VyaWFsaXplQmxvY2soeyBub2RlLCBpbmRleCwgaXNJbmxpbmUsIHJlbmRlck5vZGUgfSksIHN0eWxlID0gcHJvcHMubm9kZS5zdHlsZSB8fCBcIm5vcm1hbFwiLCBCbG9jayA9ICh0eXBlb2YgY29tcG9uZW50cy5ibG9jayA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnRzLmJsb2NrIDogY29tcG9uZW50cy5ibG9ja1tzdHlsZV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGU7XG4gICAgcmV0dXJuIEJsb2NrID09PSBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgbm9kZVR5cGU6IFwiYmxvY2tTdHlsZVwiLFxuICAgICAgdHlwZTogc3R5bGVcbiAgICB9KSwgLyogQF9fUFVSRV9fICovIGpzeChCbG9jaywgeyAuLi5wcm9wcywgdmFsdWU6IHByb3BzLm5vZGUsIHJlbmRlck5vZGUgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJUZXh0KG5vZGUsIGtleSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IGBcbmApIHtcbiAgICAgIGNvbnN0IEhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIEhhcmRCcmVhayA/IC8qIEBfX1BVUkVfXyAqLyBqc3goSGFyZEJyZWFrLCB7fSwga2V5KSA6IGBcbmA7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnRleHQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaXNJbmxpbmUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9O1xuICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93blR5cGVXYXJuaW5nKG5vZGUuX3R5cGUpLCB7IG5vZGVUeXBlOiBcImJsb2NrXCIsIHR5cGU6IG5vZGUuX3R5cGUgfSk7XG4gICAgY29uc3QgVW5rbm93blR5cGUgPSBjb21wb25lbnRzLnVua25vd25UeXBlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFVua25vd25UeXBlLCB7IC4uLm5vZGVPcHRpb25zIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBub2RlT3B0aW9ucyA9IHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaXNJbmxpbmUsXG4gICAgICBpbmRleCxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9LCBOb2RlID0gY29tcG9uZW50cy50eXBlc1tub2RlLl90eXBlXTtcbiAgICByZXR1cm4gTm9kZSA/IC8qIEBfX1BVUkVfXyAqLyBqc3goTm9kZSwgeyAuLi5ub2RlT3B0aW9ucyB9LCBrZXkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyTm9kZTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVCbG9jayhvcHRpb25zKSB7XG4gIGNvbnN0IHsgbm9kZSwgaW5kZXgsIGlzSW5saW5lLCByZW5kZXJOb2RlIH0gPSBvcHRpb25zLCBjaGlsZHJlbiA9IGJ1aWxkTWFya3NUcmVlKG5vZGUpLm1hcChcbiAgICAoY2hpbGQsIGkpID0+IHJlbmRlck5vZGUoeyBub2RlOiBjaGlsZCwgaXNJbmxpbmU6ICEwLCBpbmRleDogaSwgcmVuZGVyTm9kZSB9KVxuICApO1xuICByZXR1cm4ge1xuICAgIF9rZXk6IG5vZGUuX2tleSB8fCBgYmxvY2stJHtpbmRleH1gLFxuICAgIGNoaWxkcmVuLFxuICAgIGluZGV4LFxuICAgIGlzSW5saW5lLFxuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG5leHBvcnQge1xuICBQb3J0YWJsZVRleHQsXG4gIGRlZmF1bHRDb21wb25lbnRzLFxuICBtZXJnZUNvbXBvbmVudHMsXG4gIHRvUGxhaW5UZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/node_modules/@portabletext/toolkit/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@portabletext/react/node_modules/@portabletext/toolkit/dist/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks)\n    return [];\n  if (!span.marks.length)\n    return [];\n  const marks = span.marks.slice(), occurences = {};\n  return marks.forEach((mark) => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1)\n        occurences[mark]++;\n      else\n        break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA], bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences)\n    return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const { children } = block, markDefs = block.markDefs ?? [];\n  if (!children || !children.length)\n    return [];\n  const sortedMarks = children.map(sortMarksByOccurences), rootNode = {\n    _type: \"@span\",\n    children: [],\n    markType: \"<unknown>\"\n  };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span)\n      continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1)\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\", index = marksNeeded.indexOf(mark);\n        if (index === -1)\n          break;\n        marksNeeded.splice(index, 1);\n      }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs == null ? void 0 : markDefs.find((def) => def._key === markKey), markType = markDef ? markDef._type : markKey, node = {\n          _type: \"@span\",\n          _key: span._key,\n          children: [],\n          markDef,\n          markType,\n          markKey\n        };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1; )\n          lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(\n          lines.map((text) => ({ _type: \"@text\", text }))\n        );\n      } else\n        currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = {\n            ...lastListItem,\n            children: [...lastListItem.children, newList]\n          };\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else\n          currentList.children.push(\n            newList\n          );\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, { level: block.level || 1 });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1, style = matching.listItem || \"normal\", filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style)\n    return rootNode;\n  if (!(\"children\" in rootNode))\n    return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach((current) => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/, trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current))\n      return;\n    let pad = !1;\n    current.children.forEach((span) => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\", LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILHlCQUF5QjtBQUM1STtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUIsTUFBTSxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFlRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VjdXJpdHktc2lwLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3JlYWN0L25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3Rvb2xraXQvZGlzdC9pbmRleC5qcz9iYWJiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPiBcInVcIiB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MuZXZlcnkoKG1hcmspID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJiAvLyBUb29sa2l0LXR5cGVzIGxpa2UgbmVzdGVkIHNwYW5zIGFyZSBALXByZWZpeGVkXG4gICAgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICghKFwibWFya0RlZnNcIiBpbiBub2RlKSB8fCAhbm9kZS5tYXJrRGVmcyB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpICYmIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoKGRlZikgPT4gdHlwZW9mIGRlZi5fa2V5ID09IFwic3RyaW5nXCIpKSAmJiAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiYgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoKGNoaWxkKSA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spIHtcbiAgcmV0dXJuIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spICYmIFwibGlzdEl0ZW1cIiBpbiBibG9jayAmJiB0eXBlb2YgYmxvY2subGlzdEl0ZW0gPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIGJsb2NrLmxldmVsID4gXCJ1XCIgfHwgdHlwZW9mIGJsb2NrLmxldmVsID09IFwibnVtYmVyXCIpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChibG9jaykge1xuICByZXR1cm4gYmxvY2suX3R5cGUgPT09IFwiQGxpc3RcIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oc3Bhbikge1xuICByZXR1cm4gc3Bhbi5fdHlwZSA9PT0gXCJAc3BhblwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJAdGV4dFwiO1xufVxuY29uc3Qga25vd25EZWNvcmF0b3JzID0gW1wic3Ryb25nXCIsIFwiZW1cIiwgXCJjb2RlXCIsIFwidW5kZXJsaW5lXCIsIFwic3RyaWtlLXRocm91Z2hcIl07XG5mdW5jdGlvbiBzb3J0TWFya3NCeU9jY3VyZW5jZXMoc3BhbiwgaW5kZXgsIGJsb2NrQ2hpbGRyZW4pIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgfHwgIXNwYW4ubWFya3MpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoIXNwYW4ubWFya3MubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzLnNsaWNlKCksIG9jY3VyZW5jZXMgPSB7fTtcbiAgcmV0dXJuIG1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICBvY2N1cmVuY2VzW21hcmtdID0gMTtcbiAgICBmb3IgKGxldCBzaWJsaW5nSW5kZXggPSBpbmRleCArIDE7IHNpYmxpbmdJbmRleCA8IGJsb2NrQ2hpbGRyZW4ubGVuZ3RoOyBzaWJsaW5nSW5kZXgrKykge1xuICAgICAgY29uc3Qgc2libGluZyA9IGJsb2NrQ2hpbGRyZW5bc2libGluZ0luZGV4XTtcbiAgICAgIGlmIChzaWJsaW5nICYmIGlzUG9ydGFibGVUZXh0U3BhbihzaWJsaW5nKSAmJiBBcnJheS5pc0FycmF5KHNpYmxpbmcubWFya3MpICYmIHNpYmxpbmcubWFya3MuaW5kZXhPZihtYXJrKSAhPT0gLTEpXG4gICAgICAgIG9jY3VyZW5jZXNbbWFya10rKztcbiAgICAgIGVsc2VcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KSwgbWFya3Muc29ydCgobWFya0EsIG1hcmtCKSA9PiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSk7XG59XG5mdW5jdGlvbiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSB7XG4gIGNvbnN0IGFPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQV0sIGJPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQl07XG4gIGlmIChhT2NjdXJlbmNlcyAhPT0gYk9jY3VyZW5jZXMpXG4gICAgcmV0dXJuIGJPY2N1cmVuY2VzIC0gYU9jY3VyZW5jZXM7XG4gIGNvbnN0IGFLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtBKSwgYktub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0IpO1xuICByZXR1cm4gYUtub3duUG9zICE9PSBiS25vd25Qb3MgPyBhS25vd25Qb3MgLSBiS25vd25Qb3MgOiBtYXJrQS5sb2NhbGVDb21wYXJlKG1hcmtCKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTWFya3NUcmVlKGJsb2NrKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gYmxvY2ssIG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW107XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHNvcnRlZE1hcmtzID0gY2hpbGRyZW4ubWFwKHNvcnRNYXJrc0J5T2NjdXJlbmNlcyksIHJvb3ROb2RlID0ge1xuICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG1hcmtUeXBlOiBcIjx1bmtub3duPlwiXG4gIH07XG4gIGxldCBub2RlU3RhY2sgPSBbcm9vdE5vZGVdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3BhbiA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICghc3BhbilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1hcmtzTmVlZGVkID0gc29ydGVkTWFya3NbaV0gfHwgW107XG4gICAgbGV0IHBvcyA9IDE7XG4gICAgaWYgKG5vZGVTdGFjay5sZW5ndGggPiAxKVxuICAgICAgZm9yIChwb3M7IHBvcyA8IG5vZGVTdGFjay5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIGNvbnN0IG1hcmsgPSAoKF9hID0gbm9kZVN0YWNrW3Bvc10pID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrS2V5KSB8fCBcIlwiLCBpbmRleCA9IG1hcmtzTmVlZGVkLmluZGV4T2YobWFyayk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG1hcmtzTmVlZGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgbm9kZVN0YWNrID0gbm9kZVN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVN0YWNrW25vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbWFya0tleSBvZiBtYXJrc05lZWRlZCkge1xuICAgICAgICBjb25zdCBtYXJrRGVmID0gbWFya0RlZnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcmtEZWZzLmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmtLZXkpLCBtYXJrVHlwZSA9IG1hcmtEZWYgPyBtYXJrRGVmLl90eXBlIDogbWFya0tleSwgbm9kZSA9IHtcbiAgICAgICAgICBfdHlwZTogXCJAc3BhblwiLFxuICAgICAgICAgIF9rZXk6IHNwYW4uX2tleSxcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgbWFya0RlZixcbiAgICAgICAgICBtYXJrVHlwZSxcbiAgICAgICAgICBtYXJrS2V5XG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSksIG5vZGVTdGFjay5wdXNoKG5vZGUpLCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gc3Bhbi50ZXh0LnNwbGl0KGBcbmApO1xuICAgICAgICBmb3IgKGxldCBsaW5lID0gbGluZXMubGVuZ3RoOyBsaW5lLS0gPiAxOyApXG4gICAgICAgICAgbGluZXMuc3BsaWNlKGxpbmUsIDAsIGBcbmApO1xuICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChcbiAgICAgICAgICBsaW5lcy5tYXAoKHRleHQpID0+ICh7IF90eXBlOiBcIkB0ZXh0XCIsIHRleHQgfSkpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIG5lc3RMaXN0cyhibG9ja3MsIG1vZGUpIHtcbiAgY29uc3QgdHJlZSA9IFtdO1xuICBsZXQgY3VycmVudExpc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKGJsb2NrKSB7XG4gICAgICBpZiAoIWlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykpIHtcbiAgICAgICAgdHJlZS5wdXNoKGJsb2NrKSwgY3VycmVudExpc3QgPSB2b2lkIDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGlzdCkge1xuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBjdXJyZW50TGlzdCkpIHtcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA+IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgY29uc3QgbGFzdExpc3RJdGVtID0gY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIG5ld0xhc3RDaGlsZCA9IHtcbiAgICAgICAgICAgIC4uLmxhc3RMaXN0SXRlbSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLi4ubGFzdExpc3RJdGVtLmNoaWxkcmVuLCBuZXdMaXN0XVxuICAgICAgICAgIH07XG4gICAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBuZXdMYXN0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goXG4gICAgICAgICAgICBuZXdMaXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudExpc3QgPSBuZXdMaXN0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPCBjdXJyZW50TGlzdC5sZXZlbCkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXSwgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCBibG9jayk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2gsIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrLmxpc3RJdGVtICE9PSBjdXJyZW50TGlzdC5saXN0SXRlbSkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXSwgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCB7IGxldmVsOiBibG9jay5sZXZlbCB8fCAxIH0pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGlzdEl0ZW0gPT09IGJsb2NrLmxpc3RJdGVtKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBzdGF0ZSBlbmNvdW50ZXJlZCBmb3IgYmxvY2tcIiwgYmxvY2spLCB0cmVlLnB1c2goYmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGxpc3QpIHtcbiAgcmV0dXJuIChibG9jay5sZXZlbCB8fCAxKSA9PT0gbGlzdC5sZXZlbCAmJiBibG9jay5saXN0SXRlbSA9PT0gbGlzdC5saXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGxpc3RGcm9tQmxvY2soYmxvY2ssIGluZGV4LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgX3R5cGU6IFwiQGxpc3RcIixcbiAgICBfa2V5OiBgJHtibG9jay5fa2V5IHx8IGAke2luZGV4fWB9LXBhcmVudGAsXG4gICAgbW9kZSxcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcbiAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgY2hpbGRyZW46IFtibG9ja11cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0TWF0Y2hpbmcocm9vdE5vZGUsIG1hdGNoaW5nKSB7XG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMSwgc3R5bGUgPSBtYXRjaGluZy5saXN0SXRlbSB8fCBcIm5vcm1hbFwiLCBmaWx0ZXJPblR5cGUgPSB0eXBlb2YgbWF0Y2hpbmcubGlzdEl0ZW0gPT0gXCJzdHJpbmdcIjtcbiAgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qocm9vdE5vZGUpICYmIChyb290Tm9kZS5sZXZlbCB8fCAxKSA9PT0gbGV2ZWwgJiYgZmlsdGVyT25UeXBlICYmIChyb290Tm9kZS5saXN0SXRlbSB8fCBcIm5vcm1hbFwiKSA9PT0gc3R5bGUpXG4gICAgcmV0dXJuIHJvb3ROb2RlO1xuICBpZiAoIShcImNoaWxkcmVuXCIgaW4gcm9vdE5vZGUpKVxuICAgIHJldHVybjtcbiAgY29uc3Qgbm9kZSA9IHJvb3ROb2RlLmNoaWxkcmVuW3Jvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZSAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpID8gZmluZExpc3RNYXRjaGluZyhub2RlLCBtYXRjaGluZykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzcGFuVG9QbGFpblRleHQoc3Bhbikge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBzcGFuLmNoaWxkcmVuLmZvckVhY2goKGN1cnJlbnQpID0+IHtcbiAgICBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShjdXJyZW50KSA/IHRleHQgKz0gY3VycmVudC50ZXh0IDogaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihjdXJyZW50KSAmJiAodGV4dCArPSBzcGFuVG9QbGFpblRleHQoY3VycmVudCkpO1xuICB9KSwgdGV4dDtcbn1cbmNvbnN0IGxlYWRpbmdTcGFjZSA9IC9eXFxzLywgdHJhaWxpbmdTcGFjZSA9IC9cXHMkLztcbmZ1bmN0aW9uIHRvUGxhaW5UZXh0KGJsb2NrKSB7XG4gIGNvbnN0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoYmxvY2spID8gYmxvY2sgOiBbYmxvY2tdO1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBibG9ja3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUG9ydGFibGVUZXh0QmxvY2soY3VycmVudCkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHBhZCA9ICExO1xuICAgIGN1cnJlbnQuY2hpbGRyZW4uZm9yRWFjaCgoc3BhbikgPT4ge1xuICAgICAgaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pID8gKHRleHQgKz0gcGFkICYmIHRleHQgJiYgIXRyYWlsaW5nU3BhY2UudGVzdCh0ZXh0KSAmJiAhbGVhZGluZ1NwYWNlLnRlc3Qoc3Bhbi50ZXh0KSA/IFwiIFwiIDogXCJcIiwgdGV4dCArPSBzcGFuLnRleHQsIHBhZCA9ICExKSA6IHBhZCA9ICEwO1xuICAgIH0pLCBpbmRleCAhPT0gYmxvY2tzLmxlbmd0aCAtIDEgJiYgKHRleHQgKz0gYFxuXG5gKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBMSVNUX05FU1RfTU9ERV9IVE1MID0gXCJodG1sXCIsIExJU1RfTkVTVF9NT0RFX0RJUkVDVCA9IFwiZGlyZWN0XCI7XG5leHBvcnQge1xuICBMSVNUX05FU1RfTU9ERV9ESVJFQ1QsXG4gIExJU1RfTkVTVF9NT0RFX0hUTUwsXG4gIGJ1aWxkTWFya3NUcmVlLFxuICBpc1BvcnRhYmxlVGV4dEJsb2NrLFxuICBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssXG4gIGlzUG9ydGFibGVUZXh0U3BhbixcbiAgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCxcbiAgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbixcbiAgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsXG4gIG5lc3RMaXN0cyxcbiAgc29ydE1hcmtzQnlPY2N1cmVuY2VzLFxuICBzcGFuVG9QbGFpblRleHQsXG4gIHRvUGxhaW5UZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;